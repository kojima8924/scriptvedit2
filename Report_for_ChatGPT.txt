============================================================
  scriptvedit2 プロジェクト状況レポート (Claude Code → ChatGPT)
  作成日: 2026-02-10
============================================================

■ プロジェクト概要
  Python DSL で動画を構成し ffmpeg でレンダリングするツール。
  「1ファイル = 1レイヤー」アーキテクチャを採用。
  main.py がオーケストレータ、各レイヤーは独立した .py ファイル。

■ ファイル構成
  scriptvedit2/
  ├── scriptvedit.py   ← コアライブラリ (876行)
  ├── main.py          ← オーケストレータ (デモ用)
  ├── bg.py            ← 背景レイヤー (デモ用)
  ├── onigiri.py       ← おにぎりレイヤー (デモ用)
  ├── test/            ← テスト01〜12 (各test##_main.py + レイヤーファイル群)
  └── *.png, *.jpg     ← 素材画像 (変更禁止)

■ コミット履歴 (古い順)
  9ea9b69 初期コミット: DSLベースの動画構成ツール
  161ee8f プリセット記法の追加とTransform関数からtarget引数を除去
  84750c6 DSLを <= 演算子に統一（破壊的変更）
  129c334 レイヤー記法を obj.time(6) <= effect_chain の1行形式に統一
  0c12e42 pos廃止→move Effect統合、media_type導入、cache機能追加
  72a91bf 画像キャッシュの透過対応と1ファイル1レイヤーテスト10件追加
  d44a0b3 anchor/pause/until機能と2パスアーキテクチャを追加
  3fc1416 Expr式ビルダー導入: Effect引数をfloat/lambda(u)/Expr統一（破壊的変更）
  6b09de3 layer()遅延化と2パスplan/render分離: アンカー解決の堅牢化

============================================================
■ 【最新】 layer()遅延化と2パスplan/render分離 (6b09de3)
============================================================

  ★ render()がplan pass→render passの2段階になった。

  ◆ 変更内容
    1. layer() は登録のみ（遅延実行）
       - 旧: layer()呼び出し時にexec()でレイヤーファイルを即実行
       - 新: (filename, priority) を _layer_files に記録するだけ
       - 実際の実行は render() 内で _exec_layer() 経由

    2. render() が2パス構成に
       - Plan pass: _plan_resolve() → アンカーの固定点反復解決
         - cache() は no-op（selfを返す。タイミング計算のみ）
         - _resolve_anchors(check_unresolved=False) で反復解決
         - アンカー値が収束するまで繰り返し（最大 len(files)+2 回）
       - Render pass: 本実行
         - anchors確定済みの状態でレイヤーを再実行
         - cache() は通常動作（ファイル出力）
         - _resolve_anchors(check_unresolved=True) で最終確認

    3. anchor() に同名重複チェック追加
       - _anchor_defined_in で定義元ファイルを記録
       - 同一ファイル内の再定義はOK（plan反復で発生するため）
       - 異なるファイルからの同名定義は RuntimeError

    4. 未定義アンカーの診断改善
       - 参照先と定義済みアンカー一覧を表示

  ◆ 内部メソッド
    _plan_resolve()     ... 固定点反復でアンカー解決（plan pass本体）
    _exec_layer(f, p)   ... レイヤーファイルfをexec実行
    _mode               ... "plan" or "render"（cache動作を制御）
    _layer_files         ... [(filename, priority)] の登録リスト
    _anchor_defined_in  ... {name: filename} の診断情報
    _current_layer_file ... 実行中のファイル名

============================================================
■ Expr式ビルダー (3fc1416)
============================================================

  ★破壊的変更: Effect引数のセマンティクスが変わった。

  旧仕様:
    scale(0.5)      → 0.5→1.0にアニメーション
    fade(alpha=0)    → 0→1にフェードイン

  新仕様:
    scale(0.5)                        → 定数0.5倍（アニメーションなし）
    scale(lambda u: lerp(0.5, 1, u))  → 0.5→1.0にアニメーション（旧動作の再現）
    fade(0.5)                         → 定数0.5の不透明度
    fade(lambda u: u)                 → 0→1にフェードイン（旧動作の再現）

  ◆ Exprクラス群
    Expr        ... 基底クラス。演算子オーバーロード (+,-,*,/,**,neg,abs)
    Const(v)    ... 定数ノード → "v"
    Var("u")    ... 変数ノード → u_expr (正規化時間0〜1)
    _BinOp      ... 二項演算 → "(left op right)"
    _UnOp       ... 単項演算 → "(op x)"
    _FuncCall   ... 関数呼び出し → "name(arg1\,arg2\,...)"

  ◆ _resolve_param(param)
    float/int   → Const(param)
    lambda(u)   → lambdaにVar("u")を渡してExpr式木を構築
    Expr        → そのまま

  ◆ 数学関数（from scriptvedit import * で使用可能）
    三角:       sin, cos, tan, asin, acos, atan, atan2
    双曲線:     sinh, cosh, tanh
    指数/対数:  exp, log, sqrt, log10, cbrt
    丸め:       floor, ceil, trunc
    補間:       lerp(a, b, t) = a + (b-a)*t
    クランプ:   clip(x, lo, hi), clamp (エイリアス)
    ステップ:   step(edge, x), smoothstep(edge0, edge1, x)
    その他:     mod(a, b), frac(x), deg2rad(x), rad2deg(x)
    組み込み互換: abs, min, max, round, pow
      → Expr引数ならffmpeg式生成、通常値ならPython組み込み動作
    定数:       PI = 3.141592653589793, E = 2.718281828459045

  ◆ DSL使用例
    # 定数スケール（新しいセマンティクス）
    obj.time(5) <= scale(0.5)

    # アニメーション（lambda形式）
    obj.time(5) <= scale(lambda u: lerp(0.5, 1, u))

    # sin波フェード（フェードイン→フェードアウト）
    obj.time(4) <= fade(lambda u: sin(u * PI))

    # lambda move
    obj.time(4) <= move(x=lambda u: lerp(0.2, 0.8, u), y=0.5, anchor="center")

  ◆ move() の from/to 引数
    move(from_x=0.1, to_x=0.9, ...) は内部で
    lerp(0.1, 0.9, u) の Expr に自動変換される（後方互換）

============================================================
■ DSL記法 (現在の最新仕様)
============================================================

  ◆ オーケストレータ (main.py)
    from scriptvedit import *
    p = Project()
    p.configure(width=1280, height=720, fps=30, background_color="black")
    p.layer("bg.py", priority=0)
    p.layer("onigiri.py", priority=1)
    p.render("output.mp4")

  ◆ レイヤーファイル (1ファイル=1レイヤー)
    from scriptvedit import *
    obj = Object("image.png")
    obj <= resize(sx=0.3, sy=0.3)
    obj.time(6) <= move(x=0.5, y=0.5, anchor="center") \
                   & scale(lambda u: lerp(0.5, 1, u)) \
                   & fade(lambda u: u)

  ◆ 演算子
    obj <= Transform/TransformChain     ... Transform適用 (resize等)
    obj.time(N) <= Effect/EffectChain   ... 時間+Effect適用 (move, scale, fade)
    Transform | Transform               ... TransformChain
    Effect & Effect                      ... EffectChain

  ◆ Transform関数
    resize(sx=倍率, sy=倍率)

  ◆ Effect関数
    move(x=0.5, y=0.5, anchor="center")             ... 固定位置
    move(x=lambda u: ..., y=0.5, anchor="center")   ... lambda位置
    move(from_x=0.1, to_x=0.9, anchor="center")     ... from/toアニメーション
    scale(value)                ... 定数スケール
    scale(lambda u: expr)       ... lambda式スケール
    fade(alpha)                 ... 定数不透明度
    fade(lambda u: expr)        ... lambda式フェード

  ◆ キャッシュ機能
    cached = obj.cache("cache.png")         ... 透過PNG出力 (背景なし)
    cached = obj.cache("cache.mp4")         ... 動画出力 (背景あり)
    cached.time(5) <= move(...) & scale(...)
    ※ planモードではno-op（selfを返す）

============================================================
■ anchor/pause/until 機能
============================================================

  ◆ anchor(name)
    レイヤー内の現在の累積時刻を名前付きアンカーとして登録。
    異なるファイルからの同名定義は禁止（RuntimeError）。

  ◆ pause.time(N) / pause.until(name)
    非描画タイムラインアイテム。時間占有のみ。

  ◆ obj.until(name)
    durationをアンカー時刻まで伸長。

  ◆ 2パスアーキテクチャ（6b09de3で改善）
    render()
      → _plan_resolve() [plan pass: 固定点反復でアンカー解決]
      → _exec_layer() × N [render pass: anchors確定済みで本実行]
      → _resolve_anchors() [最終アンカー解決]
      → _build_ffmpeg_cmd() [ffmpegコマンド構築]

============================================================
■ クラス構成 (scriptvedit.py 876行)
============================================================

  Expr系 (L8-131):
  Expr, Const, Var, _BinOp, _UnOp, _FuncCall, _to_expr, _resolve_param

  数学関数 (L134-248):
  sin, cos, tan, ... lerp, clip, smoothstep, ... abs, min, max, round, pow
  PI, E

  Project (L266-612):
  layer(), _exec_layer(), render(), _plan_resolve(),
  render_object(), _build_ffmpeg_cmd(),
  _build_video_cache_cmd(), _build_image_cache_cmd(), _resolve_anchors()

  _build_move_exprs() (L615-644)
  TransformChain, EffectChain, Transform, Effect (L647-712)
  _AnchorMarker, Pause, Object (L715-811)

  ファクトリ関数 (L814-848):
  resize(), scale(), fade(), move()

  アンカー/同期 (L851-876):
  anchor(), _PauseFactory, pause

============================================================
■ テスト一覧 (test/ ディレクトリ)
============================================================

  test01: bg(石垣)+おにぎり対角移動+fade          5秒 darkred
  test02: 定式幕+cafe scale+fade                  4秒 black
  test03: 3レイヤーmoveアニメーション               5秒 black
  test04: 画像キャッシュ透過テスト                  3秒 white
  test05: 静的表示(エフェクトなし)                  2秒 green
  test06: 大スケール 3.0→1.0                       3秒 olive
  test07: 3レイヤー横並び                           4秒 navy
  test08: from/to アニメーション左→右               5秒 darkgreen
  test09: 4レイヤー四隅→中央                        4秒 gray
  test10: 画像キャッシュ+動画合成                    5秒 purple
  test11: anchor/pause.until クロスレイヤー同期      6秒 darkblue
  test12: Expr機能検証(sin波fade/lambda scale/move) 4秒 darkslategray

  ※ test01〜11は lambda形式に移行済み（旧アニメーション動作を再現）
  ※ test12はExpr新機能のデモ
  ※ 全テスト test01〜12 + メインデモ 2パス構成で動作確認済み

============================================================
■ 既知の制約・注意点
============================================================

  1. overlay の enable='between()' で t=0 ジャストが拾われない場合がある
     (ffmpegの浮動小数点精度の問題)

  2. cache() + until() の組み合わせ:
     planモードではcache()はno-opになるためタイミング計算は正常動作。
     ただしuntilで動的に決まるdurationの動画キャッシュは、
     render pass時点でアンカー確定済みなので正しく生成される。

  3. 同一レイヤー内のオブジェクトは順次タイムライン（直列配置）
     並列配置（同時表示）するには別レイヤーファイルにする

  4. anchor 循環参照の検出は未実装
     （反復回数上限で無限ループは防止しているが、明示的エラーは出ない）
     ※ 異なるファイルからの同名anchor定義はRuntimeErrorで検出

  5. Windows環境 (Python 3.10, ffmpeg 8.0) でのみテスト済み

  6. lambda内でmath.sin等は使えない（Expr非対応）
     scriptveditのsin, cos等を使うこと。エラーメッセージで案内される。

============================================================
■ 素材ファイル (変更禁止)
============================================================

  bg_pattern_ishigaki.jpg          石垣模様の背景
  onigiri_tenmusu.png              天むすおにぎり (透過PNG)
  figure_cafe.png                  カフェの人物 (透過PNG)
  pattern_teishiki_maku.png        定式幕 (緑/橙/黒の縦縞)
  pop_shinsyakaijin_ganbare.png    がんばれポップ (透過PNG)
  virus_message_fuyoufukyu_gaisyutsu.png  ウイルスメッセージ (透過PNG)

============================================================
■ 開発環境
============================================================

  OS: Windows 11
  Python: 3.10
  ffmpeg: 8.0-full_build
  Shell: Git Bash / PowerShell

============================================================
